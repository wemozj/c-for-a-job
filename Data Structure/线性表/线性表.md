[TOC]
## 线性表

**概念**：集合E上的一个线性表就是E中一组有穷个元素排成的序列。
* 空表：不包含任务元素的表
* 表的长度：一个表中包含的元素的个数
* 线性表是一种线性结构

**表抽象数据类型**：
```python
ADT List: # 一个表抽象数据类型
    List(self) # 表构造操作，创建ige新表
    is_empty(self) # 判断self是否为一个空表
    len(self) # 获得self的长度
    prepend(self, elem) # 将元素elem加入表中作为最后一个元素
    appen(self, elem) # 将元素elem加入表中作为最后一个元素
    insert(self, elem, i) # 将elem加入表中作为最后一个元素
    del_first(self) # 删除表中的首元素
    del_last(self) # 删除表中的尾元素
    del(self, i) # 删除表中第i个元素
    search(self, elem) # 查找元素elem在表中出现的位置，不出现时返回-1
    forall(self, op) # 对表中的每个元素执行操作op

```

线性表两种基本的实现模型：
1. 顺序表（连续表）：将表中的元素顺序地存放在一大块连续的存储区里
2. 链表（链接表）：将表元素存放在通过链接构造起来的一系列存储块里

python中的list和tuple就是采用顺序表的实现技术。

在python的官方系统中，list实现采用了如下的实际策略：在建立空表或者很小的表时，系统分配一块能容纳8个元素的存储区域；在执行插入操作时（insert或append），如果元素区满，就换一块4倍大的存储区；但如果当时的表已经很大了，系统将改变策略，换存储区时容量加倍。这里的“很大”是一个实际确定的参数，目前的值是5000。引入后一个策略是为了避免出现过多空闲的存储位置。
### 一、顺序表实现

#### 单链表

掌握一个单链表，只需要掌握这个表的首结点。

```python
class LNode:
    def __init__(self, elem, next_=None):
        self.elem = elem
        self.next = next_ # next_ 避免和标准函数next重名
```

**创建空链表**：只需要把相应的表头变量设置为空链接

**删除链表**：丢弃链表里的所有结点。python语言只需要将表指针赋值为None;c语言需要明确的操作释放一个个结点所用的存储。

**判断表是否为空**：将表头变量的值与空链接比较。在python中，就是检查相应变量的值是否为None。

**判断表是否满**：一般而言链表不会满，除非程序用完了所有可用的存储空间。

**加入元素**：前端插入、中间插入和后端插入。

### 二、链接表实现

见 linked_list.py

### 三、链表的变形和操作

**单向链表缺点**：尾端加入元素操作的效率太低，因为只能从表头开始查找，直至找到表的最后一个结点，而后才能链接新的结点。

**解决办法**：

![](https://raw.githubusercontent.com/wemozj/image/master/20190903211457.png)



---



**循环单链表**：链表最后一个结点的next域不用None，而是指向表的第一个结点。

这种表对象只需一个数据域_rear，它在逻辑上始终引用表的尾节点。前端加入


### 四、表的应用