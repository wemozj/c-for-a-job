[TOC]
## 线性表

**概念**：集合E上的一个线性表就是E中一组有穷个元素排成的序列。
* 空表：不包含任务元素的表
* 表的长度：一个表中包含的元素的个数
* 线性表是一种线性结构

**表抽象数据类型**：
```python
ADT List: # 一个表抽象数据类型
    List(self) # 表构造操作，创建ige新表
    is_empty(self) # 判断self是否为一个空表
    len(self) # 获得self的长度
    prepend(self, elem) # 将元素elem加入表中作为最后一个元素
    appen(self, elem) # 将元素elem加入表中作为最后一个元素
    insert(self, elem, i) # 将elem加入表中作为最后一个元素
    del_first(self) # 删除表中的首元素
    del_last(self) # 删除表中的尾元素
    del(self, i) # 删除表中第i个元素
    search(self, elem) # 查找元素elem在表中出现的位置，不出现时返回-1
    forall(self, op) # 对表中的每个元素执行操作op

```

线性表两种基本的实现模型：
1. 顺序表（连续表）：将表中的元素顺序地存放在一大块连续的存储区里
2. 链表（链接表）：将表元素存放在通过链接构造起来的一系列存储块里

python中的list和tuple就是采用顺序表的实现技术。

在python的官方系统中，list实现采用了如下的实际策略：在建立空表或者很小的表时，系统分配一块能容纳8个元素的存储区域；在执行插入操作时（insert或append），如果元素区满，就换一块4倍大的存储区；但如果当时的表已经很大了，系统将改变策略，换存储区时容量加倍。这里的“很大”是一个实际确定的参数，目前的值是5000。引入后一个策略是为了避免出现过多空闲的存储位置。
### 一、顺序表实现

#### 单链表

掌握一个单链表，只需要掌握这个表的首结点。

```python
class LNode:
    def __init__(self, elem, next_=None):
        self.elem = elem
        self.next = next_ # next_ 避免和标准函数next重名
```

**创建空链表**：只需要把相应的表头变量设置为空链接

**删除链表**：丢弃链表里的所有结点。python语言只需要将表指针赋值为None;c语言需要明确的操作释放一个个结点所用的存储。

**判断表是否为空**：将表头变量的值与空链接比较。在python中，就是检查相应变量的值是否为None。

**判断表是否满**：一般而言链表不会满，除非程序用完了所有可用的存储空间。

**加入元素**：前端插入、中间插入和后端插入。

### 二、链接表实现

见 linked_list.py

### 三、链表的变形和操作

**单向链表缺点**：尾端加入元素操作的效率太低，因为只能从表头开始查找，直至找到表的最后一个结点，而后才能链接新的结点。

**解决办法**：

![](https://raw.githubusercontent.com/wemozj/image/master/20190903211457.png)



---



**循环单链表**：链表最后一个结点的next域不用None，而是指向表的第一个结点。

这种表对象只需一个数据域_rear，它在逻辑上始终引用表的尾节点。前端加入结点，就是在尾结点和首结点之间加入新的首结点，尾结点引用不变。

**双链表**：设计出发点是希望两端插入和删除操作都能高效完成。从双链表的任一结点出发，可以直接找到其前后的相邻结点（都是O(1)操作）。

关键代码，修改结点类如下：

```python
class LNode:
    def __init__(self, elem, next_=None, prev=None):
        self.elem = elem
        self.next_ = None
        self.prev = prev
```

**循环双链表**：让表尾结点的next域指向表的首结点，而让表首结点的prev域指向尾结点。




### 四、表的应用

**1. Josephus问题和基于“数组“概念的解法**

Josephus问题描述：假设有n个人围坐一圈，现在要求从第k个人开始报数，报到第m个数的人退出。然后从下一个人开始继续报数并按照同样规则退出，直至所有人退出。要求按顺序各出列人的编号。

算法梗概：

- 建立一个包含n个人（编号）的表，找到第k个人，从那里开始
- 处理过程把相应表元素修改为0，表示已出列，反复做；
- 把表示第m个人的表元素修改为0。

```python
def josephus_A(n, k, m):
    people = list(range(1, n+1))
    i = k - 1
    for num in range(n):
        count = 0
        while count < m:
            if people[i] > 0:
                count += 1
            if count == m:
                print(people[i], end="")
                people[i] = 0
            i = (i + 1) % n
        if num < n-1:
             print(", ", end="")
        else:
            print("")
    return

josephus_A(10, 2, 7)
```

**2. 基于顺序表的解**

每退出一人，表的长度减1，至到长度为0时计算工作结束。

```python
def josephus_L(n, k, m):
    people = list(range(1, n+1))
    
    num, i = n, k-1
    for num in range(n, 0, -1):
        i = (i + m - 1) % num
        print(people.pop(i),
              end=(', ' if num > 1 else '\n'))
    return 
```

**3.基于循环单链表的解**

形式上看，循环单链表可以直观地表示围坐一圈的人；数人的动作可以看重在循环表中沿着next链扫描 ；一个人退出可以用相应删除相应结点的操作模拟。

```python
class Josephus(LCList):
    def turn(self, m):
        for i in range(m):
            self._rear = self._rear.next
    
    def __init__(self, n, k, m):
        LCList.__init__(self)
        for i in range(n):
            self.append(i+1)
        self.turn(k-1)
        while not self.is_empty():
            self.turn(m-1)
            print(self.pop(),
                  end=('\n' if self.is_empty() else ", "))
```



